# Calculates primes of the form 4*m^2*5^n -1 
# in this case for m=3 using a Kummer surface endomorphism coming from 
# the Jacobian of y^2 = x^5 + 2.
# Marc Paul Noordman & Eduardo Ruiz Duarte

from math import gcd, log, pow, floor

# Value for m
m = 3

# Point P = 4*m***Q on the Kummer surface,
# in standard coordinates 
start_vector = [ 
    71429962845264864436844056211288934406098597889392187153546235197837165602849711576008695381908313734609471234937954546488021882464776639292748454529759366553882505836406770368702527181916688241559099494644173735041531805288454820360192934051005629220840612524992830217534668011593871676149611785765286477014840311554114357347557390112657932913048647885469427707391965415609841498984661971848087376438514824860055857263617279011023162531987218794772814177051890761462326335661426760223537972567181821553924354891526432397756607628704877275966302401387427144095371707269561747600, 
    111190699427703249740855405846665531334135814119434200363694719236289062671747951658976187652551206937494434468559666449921990923115325758569927713775280280480863814582288611073694238631263218439123762496969799388954350275779172787762103307746163119856443955171425613710591719554072198054883144259041816202708432353325884524881501874028015102579642017432254769220405824119138644307161396787904244918663047056050989217104115478425554374911718190530127895332277086438402265299876418126027233297096498399155982562217934720564187164173337940410266272383949999229925681961756421064736, 
    55566525099246717313897129350252876101137573355312582792583386610120469230787842516056644490039448132883140750697217336055271646582268018099264803732409330118063598397935640445437323307467939208510116923501363020778239757711725472024152596291016251410309871820943859866729524537969359101048829552940338012479221971006472197724739278371966138939740338804196167275614288304302205073734153971835833746063934403601825226967118652883988811593223161081391841708754189814940412048184310042973874772457811012616930043350579911434467349270317564020149835603205838987618271947997243612304,
    -175430543907993236645154510943768185524242852549210541069607532226563812403272781369487267217897443282002355339094710951259575350800905124635175027828011451457137088023536693600084490157109623789189811189133627141609363620660157718168952970213188594958090615096907137242605029868890224591170007062119603215008241532982592698551677707740052515575559941274683011823722561254547494312892543048893257372579631559988752492349224649693022232663192006637175953923022419988536477635712643608091537336945390622812600248556802430880333827405190850449282320221703661450351334225086471918399
]

# The polynomials giving multiplication by sqrt 5
# on the Kummer surface, in standard coordinates
# (NB: use ** for exponentiation, not ^ !)
f1 = lambda x1,x2,x3,x4 :                                                          \
    320*x1**3*x2**2 + 80*x1**2*x2*x4**2 + 40*x1**2*x3**2*x4 + 80*x1*x2**2*x3*x4 -  \
    120*x1*x2*x3**3 + 5*x1*x4**4 + 40*x2**3*x3**2 + 10*x2*x3*x4**3 +               \
    10*x3**3*x4**2 
    
f2 = lambda x1,x2,x3,x4 :                                                          \
    640*x1**3*x2*x3 - 320*x1**2*x2**3 - 160*x1**2*x3*x4**2 + 120*x1*x2**2*x4**2 -  \
    40*x1*x2*x3**2*x4 + 120*x1*x3**4 - 80*x2**3*x3*x4 + 40*x2**2*x3**3 -           \
    5*x2*x4**4 + 10*x3**2*x4**3

f3 = lambda x1,x2,x3,x4 :                                                          \
    320*x1**3*x3**2 - 320*x1**2*x2**2*x3 - 40*x1**2*x4**3 - 320*x1*x2**4 -         \
    200*x1*x2*x3*x4**2 + 40*x1*x3**3*x4 + 80*x2**3*x4**2 - 120*x2**2*x3**2*x4 +    \
    5*x3*x4**4

f4 = lambda x1,x2,x3,x4 :                                                          \
    512*x1**5 + 320*x1**2*x2**2*x4 + 320*x1**2*x2*x3**2 - 40*x1*x2*x4**3 -         \
    360*x1*x3**2*x4**2 + 64*x2**5 - 40*x2*x3**3*x4 + 24*x3**5 + x4**5

mult_by_sqrt_5 = [f1,f2,f3,f4]

def lambda_mn(m,n):
  return 4*m**2 * 5**n - 1

def evaluate_mod(f, pt, N):
    '''Evaluate a list of functions f at a point pt and
    return the result modulo N. Assumes the results of 
    applying elements of f at pt are integers'''
    return [fi(*pt) % N for fi in f]
    
def test_primality(n, m=m,start_vector = start_vector, mult_by_sqrt_5 = mult_by_sqrt_5):     
    la = lambda_mn(m,n)
    curr = [x % la for x in start_vector]
    prev = [0,0,0,1]
    found_zero = False
    for r in range(0, 2*n+1):
        prev = curr
        curr = evaluate_mod(mult_by_sqrt_5, curr, la)
        if curr[0] == 0 and curr[1] == 0 and curr[2] == 0:
            found_zero = True
            break
    if not found_zero:
        return "Not prime"
    bound = 4*log(pow(la, 1/4) + 1)/log(5) 
    if r > bound:
        possible_divisors = [gcd(x, la) for x in prev]
        for d in possible_divisors:
            if d > 1 and d < la:
                return "Not prime, found divisor {}".format(d)
        return "Prime"
    return "Indeterminate, finished after {} steps (needed at least {} steps)".format(r,floor(bound)+1)


print ("n | Result")
print ("--|---------------")
for n in range(1,50):
	print (n,'|', test_primality(n))
